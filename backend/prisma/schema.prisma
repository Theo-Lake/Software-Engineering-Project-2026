generator client {
  provider = "prisma-client"
  output   = "../src/generated/prisma"
}

// Used to tell prisma to generate client code

datasource db {
  provider = "postgresql"
}

//TODO finish schemas
model User {
  userID                  Int                      @id @default(autoincrement())
  username                String                   @unique
  firstName               String
  lastName                String
  universityID            Int                      @unique
  created_at              DateTime                 @default(now()) // auto-set when row is created
  updated_at              DateTime                 @updatedAt // auto-update when row is changed
  email                   String                   @unique
  password_hash           String
  publishedJobs           Task[]
  assignedJobs            TaskAssignment[]
  occupation              String
  profilePicture          String                   @default("null")
  myPublishedReviews      Reviews[]                @relation("PublishedReviews")
  myRecievedReviews       Reviews[]                @relation("ReceivedReviews")
  emailVerified           Boolean                  @default(false)
  emailVerificationTokens EmailVerificationToken[]
  conversationsAsUser1    Conversation[]           @relation("User1")
  conversationsAsUser2    Conversation[]           @relation("User2")
  sentMessages            Message[]
}

model Task {
  taskID      Int  @id @default(autoincrement())
  // A User(publisher) can publish many jobs, though a job can only have ONE publisher m-1
  publisher   User @relation(fields: [publisherID], references: [userID], onDelete: Cascade)
  publisherID Int

  // A User(assignee) can be assigned many jobs, and a job can have many assignees m-m
  assignments TaskAssignment[]

  name          String
  type          TaskTypes
  status        Status    @default(not_Complete)
  payment       Decimal
  completedDate DateTime?
  dueDate       DateTime
  description   String
  images        String?

  created_at DateTime @default(now()) // auto-set when row is created
  updated_at DateTime @updatedAt // auto-update when row is changed

  hashtags      Hashtags[]
  conversations Conversation[]

  @@unique([taskID, publisherID])
}

// Holds the record of assigned jobs: | AssingmentID | job | Assignee |
model TaskAssignment {
  assignmentID Int  @id @default(autoincrement())
  task         Task @relation(fields: [taskID], references: [taskID], onDelete: Cascade)
  taskID       Int
  assignee     User @relation(fields: [assigneeID], references: [userID])
  assigneeID   Int

  @@unique([assignmentID, assigneeID])
}

model Hashtags {
  hashtagID  Int      @id @default(autoincrement())
  name       String   @unique
  tasks      Task[]
  created_at DateTime @default(now()) // auto-set when row is created
}

model Reviews {
  reviewID          Int     @id @default(autoincrement())
  name              String
  comment           String?
  reviewPublisher   User    @relation("PublishedReviews", fields: [reviewPublisherID], references: [userID])
  reviewPublisherID Int
  reviewAssignee    User    @relation("ReceivedReviews", fields: [reviewAssigneeID], references: [userID])
  reviewAssigneeID  Int

  created_at DateTime @default(now())
  rating     Rating
}

model EmailVerificationToken {
  id         Int      @id @default(autoincrement())
  token      String   @unique @default(uuid())
  user       User     @relation(fields: [userID], references: [userID], onDelete: Cascade)
  userID     Int
  expiresAt  DateTime
  used       Boolean  @default(false)
  created_at DateTime @default(now())
}

model Conversation {
  conversationID Int       @id @default(autoincrement())
  task           Task      @relation(fields: [taskCID], references: [taskID])
  taskCID        Int
  user1          User      @relation("User1", fields: [user1ID], references: [userID])
  user1ID        Int
  user2          User      @relation("User2", fields: [user2ID], references: [userID])
  user2ID        Int
  messages       Message[]
  created_at     DateTime  @default(now())
  updated_at     DateTime  @updatedAt
}

model Message {
  messageID      Int          @id @default(autoincrement())
  conversation   Conversation @relation(fields: [conversationID], references: [conversationID])
  conversationID Int
  sender         User         @relation(fields: [senderID], references: [userID])
  senderID       Int
  content        String
  created_at     DateTime     @default(now())
}

// ENUM TYPES: 

enum Status {
  complete
  pending
  in_Progress
  not_Complete // I use snake case in some instances, because this data will be displayed, it is easier to parse later on by replacing _ with " "
  cancelled
}

enum TaskTypes {
  tutoring
  delivery
  freelance
  moving
  tech_support
  general
  other
}

enum Rating {
  ONE
  TWO
  THREE
  FOUR
  FIVE
}

//TODO Session
